<!-- https://common-verdant-boa.glitch.me --> 
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <title>WebRTC P2P Chat</title>
        <link rel="stylesheet" href="styles.css">
    </head>
    
<body>
    <header>
        <h1>WebRTC P2P Chat</h1>
    </header>

    <div class="controls">
        <div class="id-section">
            <button id="generateIdButton">Generate Peer ID</button>
            <span>Your Peer ID:</span> <span id="peerIdDisplay">Not Connected</span>
        </div>
        <input type="text" id="peerId" placeholder="Enter Peer ID" />
        <button id="connectButton">Connect</button>
        <button id="disconnectButton" disabled>Disconnect</button>
    </div>

    <div class="status-bar">
        <h3 style="margin:0;">Connection Status: <span id="connectionStatus">Not Connected</span></h3>
    </div>

    <div class="main">
        <div id="chatLog"></div>

        <div class="composer">
            <textarea id="messageBox" placeholder="Type a message..." disabled></textarea>
            <button id="sendButton" disabled>Send</button>
        </div>
    </div>
    <script src="https://cdn.socket.io/4.5.1/socket.io.min.js"></script>
    <script>
        const socket = io("https://common-verdant-boa.glitch.me"); // Replace with your signaling server URL if needed

        let peerConnection;
        let dataChannel;
        let localSocketId;
        let targetPeerId;

        const peerIdDisplay = document.getElementById("peerIdDisplay");
        const connectionStatus = document.getElementById("connectionStatus");
        const chatLog = document.getElementById("chatLog");
        const sendButton = document.getElementById("sendButton");
        const disconnectButton = document.getElementById("disconnectButton");
        const messageBox = document.getElementById("messageBox");
        const generateIdButton = document.getElementById("generateIdButton");

        socket.on("connect", () => {
            localSocketId = socket.id;
            peerIdDisplay.textContent = localSocketId;
            console.log("Connected to signaling server. Peer ID:", localSocketId);
        });

        generateIdButton.onclick = () => {
            if (!socket.connected) {
                socket.connect();
            }
        };

        document.getElementById("connectButton").onclick = async () => {
            targetPeerId = document.getElementById("peerId").value.trim();
            if (!targetPeerId) {
                alert("Please enter a valid Peer ID!");
                return;
            }

            connectionStatus.textContent = "Connecting...";
            await createPeerConnection();

            dataChannel = peerConnection.createDataChannel("chat");
            setupDataChannel();

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            console.log("Sending offer:", offer);
            socket.emit("signal", { target: targetPeerId, signal: { offer } });
        };

        disconnectButton.onclick = () => {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            connectionStatus.textContent = "Disconnected";
            sendButton.disabled = true;
            disconnectButton.disabled = true;
            messageBox.disabled = true;
            console.log("Disconnected from Peer");
        };

        async function createPeerConnection() {
            peerConnection = new RTCPeerConnection({
                iceServers: [
                    { urls: "stun:stun.l.google.com:19302" },
                    {
                        urls: "turn:relay.metered.ca:80",
                        username: "user",
                        credential: "pass"
                    }
                ]
            });

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log("Sending ICE candidate:", event.candidate);
                    socket.emit("signal", { target: targetPeerId, signal: { candidate: event.candidate } });
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log("Connection state:", peerConnection.connectionState);
                if (peerConnection.connectionState === "connected") {
                    connectionStatus.textContent = "Connected";
                    disconnectButton.disabled = false;
                } else if (peerConnection.connectionState === "disconnected" || peerConnection.connectionState === "failed") {
                    connectionStatus.textContent = "Disconnected";
                }
            };

            peerConnection.ondatachannel = (event) => {
                console.log("DataChannel received:", event.channel);
                dataChannel = event.channel;
                setupDataChannel();
            };
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                console.log("DataChannel is open!");
                messageBox.disabled = false;
                sendButton.disabled = false;
            };

            dataChannel.onclose = () => {
                console.log("DataChannel is closed.");
                messageBox.disabled = true;
                sendButton.disabled = true;
            };

            dataChannel.onmessage = (event) => {
                const message = event.data;
                console.log("Message received:", message);
                appendMessage(message, "peer");
            };
        }

        sendButton.onclick = () => {
            const message = messageBox.value.trim();
            if (message && dataChannel && dataChannel.readyState === "open") {
                dataChannel.send(message); // Send the message
                appendMessage(message, "you"); // Display the message in the chat log
                messageBox.value = ""; // Clear the textarea
                messageBox.focus(); // Keep the keyboard open
            } else {
                console.error("DataChannel is not open. Current state:", dataChannel ? dataChannel.readyState : "no dataChannel");
            }
        };


        function triggerFloatingEffect(sender) {
    // Create the floating element
    const floatingElement = document.createElement("div");
    floatingElement.className = "floating-effect";

    // Use different emojis/colors for "you" and "peer" messages
    if (sender === "you") {
        floatingElement.textContent = "✨"; // Sparkles for your messages
        floatingElement.style.color = "#10b981"; // Green sparkles
    } else {
        floatingElement.textContent = "❤️"; // Hearts for peer messages
        floatingElement.style.color = "#ec4899"; // Pink hearts
    }

    // Position the heart near the last message
    const lastMessage = chatLog.lastElementChild; // Get the last message element
    if (lastMessage) {
        const rect = lastMessage.getBoundingClientRect(); // Get its position
        const chatLogRect = chatLog.getBoundingClientRect(); // Get chatLog's position

        // Set the floating effect's position relative to the chatLog
        floatingElement.style.left = `${rect.left - chatLogRect.left + rect.width / 2}px`;
        floatingElement.style.top = `${rect.top - chatLogRect.top}px`;
    } else {
        // Default position if no message exists
        floatingElement.style.left = "50%";
        floatingElement.style.top = "50%";
        floatingElement.style.transform = "translate(-50%, -50%)";
    }

    // Append the floating element to the chat log
    chatLog.appendChild(floatingElement);

    // Remove the floating element after the animation completes
    setTimeout(() => {
        floatingElement.remove();
    }, 1500); // Match the animation duration in CSS
}



        function appendMessage(text, sender) {
            const msgDiv = document.createElement("div");
            msgDiv.className = `message ${sender}`;
            msgDiv.textContent = text;

            // Append the new message to the chat log
            chatLog.appendChild(msgDiv);

            // Trigger floating animation for messages (both "you" and "peer")
            triggerFloatingEffect(sender);

            // Auto-scroll to the bottom
            chatLog.scrollTop = chatLog.scrollHeight;
        }




        socket.on("signal", async ({ signal, sender }) => {
            console.log("Received signal:", signal, "from:", sender);

            if (signal.offer) {
                console.log("Received offer, creating answer...");
                await createPeerConnection();
                await peerConnection.setRemoteDescription(signal.offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log("Sending answer:", answer);
                socket.emit("signal", { target: sender, signal: { answer } });
                targetPeerId = sender;
            } else if (signal.answer) {
                console.log("Received answer, setting remote description...");
                await peerConnection.setRemoteDescription(signal.answer);
            } else if (signal.candidate) {
                console.log("Received ICE candidate, adding...");
                await peerConnection.addIceCandidate(signal.candidate).catch(e => console.error(e));
            }
        });
    </script>
</body>
</html>
